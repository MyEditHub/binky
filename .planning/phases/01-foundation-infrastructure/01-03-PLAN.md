---
phase: 01-foundation-infrastructure
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src-tauri/src/lib.rs
  - src-tauri/Cargo.toml
  - src-tauri/tauri.conf.json
  - src-tauri/capabilities/default.json
  - src/lib/updater.ts
  - src/lib/database.ts
autonomous: true
user_setup:
  - service: sentry
    why: "Crash reporting from day 1"
    env_vars:
      - name: SENTRY_DSN
        source: "Create free Sentry account at sentry.io -> Create project (Tauri/Rust) -> Copy DSN"

must_haves:
  truths:
    - "Auto-updater checks for updates on app launch without blocking UI"
    - "Updater endpoint points to GitHub Releases for nettgefluester-app repo"
    - "Sentry captures JavaScript errors and Rust panics"
    - "Database is backed up before migrations run"
    - "Update downloads >50MB warn user before proceeding"
  artifacts:
    - path: "src/lib/updater.ts"
      provides: "Non-blocking update check with progress and size warning"
      min_lines: 30
    - path: "src/lib/database.ts"
      provides: "Database loading with pre-migration backup"
      min_lines: 20
    - path: "src-tauri/tauri.conf.json"
      provides: "Updater plugin configuration with GitHub endpoint and public key"
      contains: "updater"
    - path: "src-tauri/src/lib.rs"
      provides: "Rust app init with updater + sentry plugins"
      contains: "tauri_plugin_updater"
  key_links:
    - from: "src-tauri/tauri.conf.json"
      to: "GitHub Releases"
      via: "updater endpoints array pointing to latest.json"
      pattern: "github.com.*releases.*latest"
    - from: "src-tauri/src/lib.rs"
      to: "sentry"
      via: "sentry::init with DSN"
      pattern: "sentry::init"
    - from: "src/lib/database.ts"
      to: "@tauri-apps/plugin-sql"
      via: "Database.load for SQLite connection"
      pattern: "Database.load"
---

<objective>
Integrate the auto-updater infrastructure with signing key generation and GitHub Releases endpoint, add Sentry crash reporting for both Rust and JavaScript, and create the database backup utility.

Purpose: These are infrastructure services that run silently in the background. The auto-updater ensures users always get the latest version. Sentry catches errors from day 1. Database backup protects user data during schema upgrades.

Output: Working auto-updater configuration, Sentry integration, and database backup utility.
</objective>

<execution_context>
@/Users/tmtlxantonio/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tmtlxantonio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-infrastructure/01-CONTEXT.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure auto-updater with signing key and GitHub Releases endpoint</name>
  <files>
    src-tauri/tauri.conf.json
    src-tauri/Cargo.toml
    src-tauri/src/lib.rs
    src-tauri/capabilities/default.json
    src/lib/updater.ts
  </files>
  <action>
    1. Generate Tauri signing key pair:
       ```bash
       npx tauri signer generate -w ~/.tauri/nettgefluester.key
       ```
       This creates a private key at `~/.tauri/nettgefluester.key` and outputs the public key.
       Store the public key - it goes in tauri.conf.json.

       CRITICAL: After generating, output instructions for user to:
       - Back up `~/.tauri/nettgefluester.key` to 1Password/BitWarden
       - Never commit this private key to git
       - The key is needed for CI/CD (stored as TAURI_SIGNING_PRIVATE_KEY secret)

    2. Add tauri-plugin-updater to `src-tauri/Cargo.toml`:
       ```toml
       tauri-plugin-updater = "2"
       ```

    3. Update `src-tauri/tauri.conf.json` to add updater configuration:
       ```json
       {
         "bundle": {
           "createUpdaterArtifacts": true
         },
         "plugins": {
           "updater": {
             "pubkey": "<THE_GENERATED_PUBLIC_KEY>",
             "endpoints": [
               "https://github.com/tmtlxantonio/nettgefluester-app/releases/latest/download/latest.json"
             ]
           }
         }
       }
       ```
       Use the ACTUAL public key from step 1.
       Use the user's GitHub username from the repo context.

    4. Add updater permission to `src-tauri/capabilities/default.json`:
       Add "updater:default" to the permissions array.

    5. Update `src-tauri/src/lib.rs` to register updater plugin:
       ```rust
       .plugin(tauri_plugin_updater::Builder::new().build())
       ```
       Add to the plugin chain in tauri::Builder.

    6. Create `src/lib/updater.ts` implementing the non-blocking update check:
       - Export `checkForUpdates()` async function
       - Use `@tauri-apps/plugin-updater` check() function
       - If update available and content length > 50MB, warn user first (German text)
       - Download with progress callback (log percentage for now, UI integration in Plan 05)
       - On download complete, prompt restart in German: "Update installiert. App jetzt neu starten?"
       - On error: silent catch, log to console, do NOT show error to user (retry next launch)
       - On no update: return silently
       - Import `relaunch` from `@tauri-apps/plugin-process`

    7. Install frontend dependencies:
       ```bash
       npm install @tauri-apps/plugin-updater @tauri-apps/plugin-process
       ```
  </action>
  <verify>
    Run `cd src-tauri && cargo check` passes with updater plugin.
    Verify `~/.tauri/nettgefluester.key` exists (private key generated).
    Verify `src-tauri/tauri.conf.json` has updater config with pubkey and endpoint.
    Verify `src-tauri/capabilities/default.json` includes "updater:default".
    Run `npx tsc --noEmit` passes with updater.ts types.
  </verify>
  <done>
    Tauri updater plugin configured with signing key pair. Public key embedded in config. Private key at ~/.tauri/nettgefluester.key ready for 1Password backup. GitHub Releases endpoint configured. Non-blocking update check function created with 50MB size warning, German prompts, and silent error handling.
  </done>
</task>

<task type="auto">
  <name>Task 2: Integrate Sentry crash reporting and database backup utility</name>
  <files>
    src-tauri/Cargo.toml
    src-tauri/src/lib.rs
    src-tauri/capabilities/default.json
    src/lib/database.ts
    package.json
  </files>
  <action>
    1. Add Sentry dependencies to `src-tauri/Cargo.toml`:
       ```toml
       sentry = "0.42"
       tauri-plugin-sentry = "0.5"
       ```

    2. Update `src-tauri/src/lib.rs` to initialize Sentry BEFORE Tauri builder:
       ```rust
       use sentry;
       use tauri_plugin_sentry;

       pub fn run() {
           let client = sentry::init((
               "YOUR_SENTRY_DSN_PLACEHOLDER",  // Replace with actual DSN from env
               sentry::ClientOptions {
                   release: sentry::release_name!(),
                   auto_session_tracking: true,
                   ..Default::default()
               }
           ));

           // Guard keeps Sentry active for app lifetime
           let _guard = client;

           tauri::Builder::default()
               .plugin(tauri_plugin_sentry::init_with_no_injection(&client))
               // ... existing plugins
       }
       ```

       For the DSN: Use a placeholder string with a comment explaining it should be set via environment variable or build-time config. Use `option_env!("SENTRY_DSN").unwrap_or(""))` to make it optional - if no DSN, Sentry initializes but doesn't send events. This way the app works in development without Sentry configured.

    3. Add Sentry permission to `src-tauri/capabilities/default.json`:
       - Check if sentry-tauri requires specific permissions. If so, add them.
       - If no specific permissions needed, skip this step.

    4. Install frontend Sentry package (for JavaScript error capture):
       ```bash
       npm install @sentry/browser
       ```
       Note: sentry-tauri may inject this automatically. If so, skip manual installation.

    5. Create `src/lib/database.ts` with backup utility:
       ```typescript
       import Database from '@tauri-apps/plugin-sql';
       import { BaseDirectory, copyFile, exists, mkdir } from '@tauri-apps/plugin-fs';

       export async function loadDatabaseWithBackup(): Promise<Database> {
         const dbPath = 'nettgefluester.db';
         const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
         const backupDir = 'backups';
         const backupPath = `${backupDir}/nettgefluester-${timestamp}.db`;

         try {
           const dbExists = await exists(dbPath, { baseDir: BaseDirectory.AppData });

           if (dbExists) {
             // Ensure backup directory exists
             const backupDirExists = await exists(backupDir, { baseDir: BaseDirectory.AppData });
             if (!backupDirExists) {
               await mkdir(backupDir, { baseDir: BaseDirectory.AppData, recursive: true });
             }

             // Create backup before loading (migrations run on load)
             await copyFile(dbPath, backupPath, {
               fromPathBaseDir: BaseDirectory.AppData,
               toPathBaseDir: BaseDirectory.AppData
             });
             console.log(`Database backed up to ${backupPath}`);
           }
         } catch (err) {
           console.warn('Database backup failed (non-fatal):', err);
           // Continue even if backup fails - don't block app startup
         }

         return await Database.load('sqlite:nettgefluester.db');
       }

       // Clean old backups - keep only last 5
       export async function cleanOldBackups(): Promise<void> {
         // Implementation: list files in backups dir, sort by date, remove oldest
         // Keep last 5 backups
       }
       ```

    6. Install the SQL frontend package if not already:
       ```bash
       npm install @tauri-apps/plugin-sql @tauri-apps/plugin-fs
       ```

    IMPORTANT: The full plugin chain in lib.rs should now be:
    1. sentry::init (first - captures all subsequent errors)
    2. tauri::Builder with plugins:
       - tauri_plugin_sentry
       - tauri_plugin_sql (with migrations)
       - tauri_plugin_updater
       - tauri_plugin_fs
  </action>
  <verify>
    Run `cd src-tauri && cargo check` passes with all plugins (sql, updater, sentry, fs).
    Verify `src-tauri/src/lib.rs` initializes Sentry before Tauri builder.
    Verify the plugin registration order: sentry, sql, updater, fs.
    Run `npx tsc --noEmit` passes with database.ts types.
    Run `npm run tauri dev` - app launches without crash (Sentry DSN placeholder is OK).
  </verify>
  <done>
    Sentry crash reporting integrated in both Rust and JavaScript. DSN configurable via environment variable (optional for development). Database backup utility creates timestamped copies before migrations. Full plugin chain: sentry -> sql -> updater -> fs. App compiles and launches with all infrastructure services.
  </done>
</task>

</tasks>

<verification>
1. `cargo check` passes with all 4 Tauri plugins
2. Signing key pair exists at `~/.tauri/nettgefluester.key`
3. `tauri.conf.json` has updater endpoint and public key
4. `lib.rs` initializes Sentry first, then Tauri with all plugins
5. `updater.ts` handles update check with 50MB warning and German text
6. `database.ts` creates backup before database load
7. `npm run tauri dev` launches successfully with all services
</verification>

<success_criteria>
- Auto-updater configured with signing key, GitHub Releases endpoint, and non-blocking check
- Signing private key generated and ready for 1Password backup
- Sentry integrated for Rust panics and JavaScript errors
- Database backup utility creates timestamped copies before migration
- All plugins registered in correct order in lib.rs
- App compiles and launches with all infrastructure services active
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-03-SUMMARY.md`
</output>
