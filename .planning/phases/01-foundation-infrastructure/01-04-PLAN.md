---
phase: 01-foundation-infrastructure
plan: 04
type: execute
wave: 3
depends_on: ["01-03"]
files_modified:
  - .github/workflows/release.yml
  - scripts/bump-version.sh
  - src-tauri/tauri.conf.json
autonomous: true

must_haves:
  truths:
    - "GitHub Actions workflow builds macOS app for both ARM and Intel architectures"
    - "Workflow uses Rust cache for faster subsequent builds"
    - "Workflow injects signing keys and Apple certificates from GitHub Secrets"
    - "Workflow creates GitHub Release with PKG installers and updater artifacts (latest.json, .tar.gz, .sig)"
    - "tauri.conf.json configured to produce PKG bundles for macOS distribution"
    - "Version bump script updates both package.json and tauri.conf.json"
  artifacts:
    - path: ".github/workflows/release.yml"
      provides: "CI/CD pipeline for macOS builds and releases"
      min_lines: 50
      contains: "tauri-apps/tauri-action"
    - path: "scripts/bump-version.sh"
      provides: "Version synchronization script"
      min_lines: 15
      contains: "package.json"
  key_links:
    - from: ".github/workflows/release.yml"
      to: "src-tauri/tauri.conf.json"
      via: "tauri-action reads config for build"
      pattern: "tauri-action"
    - from: ".github/workflows/release.yml"
      to: "GitHub Secrets"
      via: "Environment variables for signing"
      pattern: "TAURI_SIGNING_PRIVATE_KEY"
---

<objective>
Create the GitHub Actions CI/CD pipeline that builds, signs, and releases the macOS app for both ARM and Intel architectures, plus a version bump utility script.

Purpose: Without CI/CD, there's no way to distribute the app to users. This pipeline automates the build -> sign -> release flow that produces PKG installers and auto-updater artifacts.

Output: Working release.yml workflow and version bump script.
</objective>

<execution_context>
@/Users/tmtlxantonio/.claude/get-shit-done/workflows/execute-plan.md
@/Users/tmtlxantonio/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-infrastructure/01-CONTEXT.md
@.planning/phases/01-foundation-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-infrastructure/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Configure PKG bundling and create GitHub Actions release workflow for macOS ARM + Intel builds</name>
  <files>
    .github/workflows/release.yml
    src-tauri/tauri.conf.json
  </files>
  <action>
    1. First, configure `src-tauri/tauri.conf.json` to produce PKG installers:
       Update the bundle configuration to include PKG format:
       ```json
       {
         "bundle": {
           "active": true,
           "targets": ["app", "dmg", "updater"],
           "macOS": {
             "minimumSystemVersion": "12.0",
             "entitlements": "./Entitlements.plist"
           },
           "createUpdaterArtifacts": true
         }
       }
       ```

       CRITICAL: The "targets" array must include both "dmg" (for manual downloads) and "updater" (for auto-update .tar.gz).
       PKG creation happens automatically when the app is signed and notarized on macOS - tauri-action handles this.
       The PKG will be created alongside the DMG in the GitHub Release.

    2. Create `.github/workflows/release.yml` based on the Tauri v2 official GitHub Actions documentation and the Editor-Workshop proven setup.

    Workflow triggers:
    - Push to `release` branch (standard release flow)
    - Manual workflow_dispatch (for emergency hotfix releases)

    Jobs structure:
    ```yaml
    name: Release

    on:
      push:
        branches:
          - release
      workflow_dispatch:

    jobs:
      publish-tauri:
        permissions:
          contents: write
        strategy:
          fail-fast: false
          matrix:
            include:
              - platform: 'macos-latest'
                args: '--target aarch64-apple-darwin'
              - platform: 'macos-latest'
                args: '--target x86_64-apple-darwin'

        runs-on: ${{ matrix.platform }}
        steps:
          - uses: actions/checkout@v4

          - name: Setup Node
            uses: actions/setup-node@v4
            with:
              node-version: lts/*
              cache: 'npm'

          - name: Install Rust stable
            uses: dtolnay/rust-toolchain@stable
            with:
              targets: aarch64-apple-darwin,x86_64-apple-darwin

          - name: Rust cache
            uses: swatinem/rust-cache@v2
            with:
              workspaces: './src-tauri -> target'

          - name: Install frontend dependencies
            run: npm install

          - name: Build and release Tauri app
            uses: tauri-apps/tauri-action@v0
            env:
              GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
              APPLE_CERTIFICATE: ${{ secrets.APPLE_CERTIFICATE }}
              APPLE_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATE_PASSWORD }}
              APPLE_SIGNING_IDENTITY: ${{ secrets.APPLE_SIGNING_IDENTITY }}
              APPLE_ID: ${{ secrets.APPLE_ID }}
              APPLE_PASSWORD: ${{ secrets.APPLE_PASSWORD }}
              APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
              TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
              TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
              SENTRY_DSN: ${{ secrets.SENTRY_DSN }}
            with:
              tagName: app-v__VERSION__
              releaseName: 'Nettgefluster v__VERSION__'
              releaseBody: 'Neue Version verfuegbar. Details im Changelog.'
              releaseDraft: false
              prerelease: false
              args: ${{ matrix.args }}
    ```

    Key details:
    - Separate builds for ARM (aarch64-apple-darwin) and Intel (x86_64-apple-darwin) as required by Tauri v2
    - `swatinem/rust-cache@v2` saves ~90% CI build time on subsequent builds
    - All Apple signing certificates and Tauri signing key injected via GitHub Secrets
    - `createUpdaterArtifacts: true` in tauri.conf.json ensures latest.json + signatures are generated
    - Release body in German (matches app language)
    - `fail-fast: false` so if one architecture fails, the other still completes

    Add comments in the YAML explaining:
    - Which GitHub Secrets need to be configured
    - How to trigger a release (push to release branch)
    - What artifacts are produced (PKG installer, DMG, updater JSON, signatures)
  </action>
  <verify>
    Verify `src-tauri/tauri.conf.json` bundle.targets includes "app", "dmg", and "updater".
    Verify `bundle.createUpdaterArtifacts` is set to true.
    Verify `.github/workflows/release.yml` exists and is valid YAML.
    Run `python3 -c "import yaml; yaml.safe_load(open('.github/workflows/release.yml'))"` or similar YAML validation.
    Verify workflow references both aarch64-apple-darwin and x86_64-apple-darwin targets.
    Verify all required secrets are referenced (GITHUB_TOKEN, APPLE_*, TAURI_SIGNING_*).
    Verify `swatinem/rust-cache@v2` is used for build caching.
  </verify>
  <done>
    tauri.conf.json configured to produce PKG installers and updater artifacts. GitHub Actions workflow created that builds macOS app for ARM + Intel, signs with Apple certificates, generates PKG/DMG/updater artifacts, and publishes to GitHub Releases. Rust cache enabled for faster builds. All secrets documented.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create version bump script and document required GitHub Secrets</name>
  <files>
    scripts/bump-version.sh
  </files>
  <action>
    1. Create `scripts/bump-version.sh`:
       A bash script that synchronizes version numbers across:
       - `package.json` (npm version field)
       - `src-tauri/tauri.conf.json` (Tauri version field)
       - `src-tauri/Cargo.toml` (Rust crate version field)

       Usage: `./scripts/bump-version.sh 0.2.0`

       Script should:
       - Accept version string as argument (e.g., "0.2.0")
       - Validate version format (semver: X.Y.Z)
       - Update all three files using sed
       - Print confirmation of what was changed
       - Optionally create git commit and tag

       ```bash
       #!/bin/bash
       set -e

       VERSION=$1

       if [ -z "$VERSION" ]; then
         echo "Usage: ./scripts/bump-version.sh <version>"
         echo "Example: ./scripts/bump-version.sh 0.2.0"
         exit 1
       fi

       # Validate semver format
       if ! [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
         echo "Error: Version must be in semver format (X.Y.Z)"
         exit 1
       fi

       echo "Bumping version to $VERSION..."

       # Update package.json
       sed -i '' "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" package.json
       echo "  Updated package.json"

       # Update tauri.conf.json
       sed -i '' "s/\"version\": \".*\"/\"version\": \"$VERSION\"/" src-tauri/tauri.conf.json
       echo "  Updated src-tauri/tauri.conf.json"

       # Update Cargo.toml (first version line only)
       sed -i '' "0,/^version = \".*\"$/s//version = \"$VERSION\"/" src-tauri/Cargo.toml
       echo "  Updated src-tauri/Cargo.toml"

       echo ""
       echo "Version bumped to $VERSION"
       echo "Next: git add -A && git commit -m 'chore: bump version to v$VERSION'"
       ```

       Make executable: `chmod +x scripts/bump-version.sh`

    2. Add a comment block at the top of release.yml (or create a companion README) documenting:
       Required GitHub Secrets:
       - `APPLE_CERTIFICATE`: Base64-encoded .p12 certificate file
       - `APPLE_CERTIFICATE_PASSWORD`: Password for the .p12 certificate
       - `APPLE_SIGNING_IDENTITY`: Certificate name (e.g., "Developer ID Application: Name (TEAMID)")
       - `APPLE_ID`: Apple ID email for notarization
       - `APPLE_PASSWORD`: App-specific password for notarization
       - `APPLE_TEAM_ID`: Apple Developer Team ID
       - `TAURI_SIGNING_PRIVATE_KEY`: Contents of ~/.tauri/nettgefluester.key
       - `TAURI_SIGNING_PRIVATE_KEY_PASSWORD`: Password set during key generation
       - `SENTRY_DSN`: Sentry DSN for crash reporting (optional)
  </action>
  <verify>
    Run `bash -n scripts/bump-version.sh` to verify script syntax is valid.
    Run `./scripts/bump-version.sh 0.1.0` and verify all three files are updated.
    Verify the release.yml has comments documenting required secrets.
  </verify>
  <done>
    Version bump script synchronizes version across package.json, tauri.conf.json, and Cargo.toml. GitHub Secrets requirements documented in workflow file. Release process: bump version -> commit -> push to release branch -> CI/CD builds and publishes.
  </done>
</task>

</tasks>

<verification>
1. `src-tauri/tauri.conf.json` bundle.targets includes PKG-producing configuration
2. `.github/workflows/release.yml` exists with valid YAML syntax
3. Workflow builds for both ARM and Intel macOS targets
4. All required GitHub Secrets are referenced in environment variables
5. Rust cache is configured for build performance
6. `scripts/bump-version.sh` updates all 3 version files
7. Workflow produces tagged releases with PKG installers and updater artifacts
</verification>

<success_criteria>
- tauri.conf.json configured to produce PKG installers for macOS distribution
- CI/CD workflow ready to build macOS app for ARM + Intel
- All signing secrets documented and referenced
- Rust cache configured for fast subsequent builds
- Version bump script keeps version in sync across files
- Release flow documented: bump -> commit -> push to release branch
- PKG installer will be created alongside DMG and updater artifacts
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-infrastructure/01-04-SUMMARY.md`
</output>
